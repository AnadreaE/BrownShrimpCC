development.df_juvI <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- 0.6 #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvI[as.character(i)] <- development
}
development.df_juvI = development.df_juvI[ , !(names(development.df_juvI) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvI <- sapply(development.df_juvI, function(col){
BrownShrimp::count_devDays(col, juvI_min, juvI_max) } )
plot( (1:length(dev_time_juvI))*0.1, dev_time_juvI, main = "Development days Juvenile I \n min_size = 0.6 cm and max_size = 1 cm" )
plot( (1:length(dev_time_juvI))*0.1, 1/dev_time_juvI, main = "1/Development days Juvenile I \n min_size = 0.6 cm and max_size = 1 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvI == 1095 | dev_time_juvI == 0)
dev_time_JUVI_reduced <- dev_time_juvI[dev_time_juvI != 1095 & dev_time_juvI != 0]
temperature_range_red_juvI <- temperature_range[-indexes_1095]
k_vals_reduced_JUVI = k_vals_F[-indexes_1095]
devTime_juvI_inv_reduced = 1/dev_time_JUVI_reduced
k_vals_reduced_JUVI_inv = 1/k_vals_reduced_JUVI
fit_JuvI = lm(dev_time_JUVI_reduced ~ k_vals_reduced_JUVI_inv )
summary(fit_JuvI)
plot( (1:length(dev_time_juvI))*0.1, dev_time_juvI,
main = paste("Development days JuvenileI vs fit \n min_size =", juvI_min, "mm and max_size = ", juvI_max ,"mm") )
lines(temperature_range_red_juvI, predict(fit_JuvI), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### JUVI ####
development.df_juvI <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- 0.6 #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvI[as.character(i)] <- development
}
development.df_juvI = development.df_juvI[ , !(names(development.df_juvI) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvI <- sapply(development.df_juvI, function(col){
BrownShrimp::count_devDays(col, juvI_min, juvI_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_juvI))*0.1, dev_time_juvI, main = "Development days Juvenile I \n min_size = 0.6 cm and max_size = 1 cm" )
plot( (1:length(dev_time_juvI))*0.1, 1/dev_time_juvI, main = "1/Development days Juvenile I \n min_size = 0.6 cm and max_size = 1 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvI == 1095 | dev_time_juvI == 0)
dev_time_JUVI_reduced <- dev_time_juvI[dev_time_juvI != 1095 & dev_time_juvI != 0]
temperature_range_red_juvI <- temperature_range[-indexes_1095]
k_vals_reduced_JUVI = k_vals_F[-indexes_1095]
devTime_juvI_inv_reduced = 1/dev_time_JUVI_reduced
k_vals_reduced_JUVI_inv = 1/k_vals_reduced_JUVI
fit_JuvI = lm(dev_time_JUVI_reduced ~ k_vals_reduced_JUVI_inv )
summary(fit_JuvI)
plot( (1:length(dev_time_juvI))*0.1, dev_time_juvI,
main = paste("Development days JuvenileI vs fit \n min_size =", juvI_min, "mm and max_size = ", juvI_max ,"mm") )
lines(temperature_range_red_juvI, predict(fit_JuvI), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### JUV II ####
development.df_juvII <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- juvII_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvII[as.character(i)] <- development
}
development.df_juvII = development.df_juvII[ , !(names(development.df_juvII) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvII <- sapply(development.df_juvII, function(col){
BrownShrimp::count_devDays(col, juvII_min, juvII_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_juvII))*0.1, dev_time_juvII, main = "Development days Juvenile I \n min_size = 0.6 cm and max_size = 1 cm" )
plot( (1:length(dev_time_juvII))*0.1, 1/dev_time_juvII, main = "1/Development days Juvenile II \n min_size = 1 cm and max_size = 2 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvII == 1095 | dev_time_juvII == 0)
dev_time_juvII_reduced <- dev_time_juvII[dev_time_juvII != 1095 & dev_time_juvII != 0 ]
temperature_range_red_juvII <- temperature_range[-indexes_1095]
k_vals_reduced_juvII = k_vals_F[-indexes_1095]
devTime_juvII_inv_reduced = 1/dev_time_juvII_reduced
k_vals_reduced_juvII_inv = 1/k_vals_reduced_juvII
fit_juvII = lm(dev_time_juvII_reduced ~ k_vals_reduced_juvII_inv )
summary(fit_juvII)
plot( (1:length(dev_time_juvII))*0.1, dev_time_juvII,
main = paste("Development days JuvenileI vs fit \n min_size =", juvII_min, "mm and max_size = ", juvII_max ,"mm"))
lines(temperature_range_red_juvII, predict(fit_juvII), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### JUV III ####
development.df_juvIII <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- juvIII_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvIII[as.character(i)] <- development
}
development.df_juvIII = development.df_juvIII[ , !(names(development.df_juvIII) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvIII <- sapply(development.df_juvIII, function(col){
BrownShrimp::count_devDays(col, juvIII_min, juvIII_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_juvIII))*0.1, dev_time_juvIII, main = "Development days Juvenile III \n min_size = 0.6 cm and max_size = 1 cm" )
plot( (1:length(dev_time_juvIII))*0.1, 1/dev_time_juvIII, main = "1/Development days Juvenile III \n min_size = 2 cm and max_size = 3 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvIII == 1095 | dev_time_juvIII == 0)
dev_time_juvIII_reduced <- dev_time_juvIII[dev_time_juvIII != 1095 & dev_time_juvIII != 0]
temperature_range_red_juvIII <- temperature_range[-indexes_1095]
k_vals_reduced_juvIII = k_vals_F[-indexes_1095]
devTime_juvIII_inv_reduced = 1/dev_time_juvIII_reduced
k_vals_reduced_juvIII_inv = 1/k_vals_reduced_juvIII
fit_juvIII = lm(dev_time_juvIII_reduced ~ k_vals_reduced_juvIII_inv )
summary(fit_juvIII)
plot( (1:length(dev_time_juvIII))*0.1, dev_time_juvIII,
main = paste("Development days JuvenileI vs fit \n min_size =", juvIII_min, "mm and max_size = ", juvIII_max ,"mm") )
lines(temperature_range_red_juvIII, predict(fit_juvIII), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### JUV IV ####
development.df_juvIV <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- juvIV_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvIV[as.character(i)] <- development
}
development.df_juvIV = development.df_juvIV[ , !(names(development.df_juvIV) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvIV <- sapply(development.df_juvIV, function(col){
BrownShrimp::count_devDays(col, juvIV_min, juvIV_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_juvIV))*0.1, dev_time_juvIV, main = "Development days Juvenile IV \n min_size = 3 cm and max_size = 4 cm" )
plot( (1:length(dev_time_juvIV))*0.1, 1/dev_time_juvIV, main = "1/Development days Juvenile IV \n min_size = 3 cm and max_size = 4 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvIV == 1095 | dev_time_juvIV == 0)
dev_time_juvIV_reduced <- dev_time_juvIV[dev_time_juvIV != 1095 & dev_time_juvIV != 0]
temperature_range_red_juvIV <- temperature_range[-indexes_1095]
k_vals_reduced_juvIV = k_vals_F[-indexes_1095]
devTime_juvIV_inv_reduced = 1/dev_time_juvIV_reduced
k_vals_reduced_juvIV_inv = 1/k_vals_reduced_juvIV
fit_juvIV = lm(dev_time_juvIV_reduced ~ k_vals_reduced_juvIV_inv )
summary(fit_juvIV)
plot( (1:length(dev_time_juvIV))*0.1, dev_time_juvIV,
main = paste("Development days JuvenileI vs fit \n min_size =", juvIV_min, "mm and max_size = ", juvIV_max ,"mm") )
lines(temperature_range_red_juvIV, predict(fit_juvIV), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### JUV V ####
development.df_juvV <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- juvV_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_juvV[as.character(i)] <- development
}
development.df_juvV = development.df_juvV[ , !(names(development.df_juvV) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_juvV <- sapply(development.df_juvV, function(col){
BrownShrimp::count_devDays(col, juvV_min, juvV_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_juvV))*0.1, dev_time_juvV, main = "Development days Juvenile V \n min_size = 4 cm and max_size = 5 cm" )
plot( (1:length(dev_time_juvV))*0.1, 1/dev_time_juvV, main = "1/Development days Juvenile V \n min_size = 4 cm and max_size = 5 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_juvV == 1095 | dev_time_juvV == 0)
dev_time_juvV_reduced <- dev_time_juvV[dev_time_juvV != 1095  & dev_time_juvV != 0]
temperature_range_red_juvV <- temperature_range[-indexes_1095]
k_vals_reduced_juvV = k_vals_F[-indexes_1095]
devTime_juvV_inv_reduced = 1/dev_time_juvV_reduced
k_vals_reduced_juvV_inv = 1/k_vals_reduced_juvV
fit_juvV = lm(dev_time_juvV_reduced ~ k_vals_reduced_juvV_inv )
summary(fit_juvV)
plot( (1:length(dev_time_juvV))*0.1, dev_time_juvV,
main = paste("Development days JuvenileI vs fit \n min_size =", juvV_min, "mm and max_size = ", juvV_max ,"mm") )
lines(temperature_range_red_juvV, predict(fit_juvV), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### ADULT I####
development.df_aduI <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- adultI_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_aduI[as.character(i)] <- development
}
development.df_aduI = development.df_aduI[ , !(names(development.df_aduI) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_aduI <- sapply(development.df_aduI, function(col){
BrownShrimp::count_devDays(col, adultI_min, adultI_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_aduI))*0.1, dev_time_aduI, main = "Development days Adult I \n min_size = 5 cm and max_size = 6 cm" )
plot( (1:length(dev_time_aduI))*0.1, 1/dev_time_aduI, main = "1/Development days Adult I \n min_size = 5 cm and max_size = 6 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_aduI == 1095 | dev_time_aduI == 0)
dev_time_aduI_reduced <- dev_time_aduI[dev_time_aduI != 1095 & dev_time_aduI != 0]
temperature_range_red_aduI <- temperature_range[-indexes_1095]
k_vals_reduced_aduI = k_vals_F[-indexes_1095]
devTime_aduI_inv_reduced = 1/dev_time_aduI_reduced
k_vals_reduced_aduI_inv = 1/k_vals_reduced_aduI
fit_aduI = lm(dev_time_aduI_reduced ~ k_vals_reduced_aduI_inv )
summary(fit_aduI)
plot( (1:length(dev_time_aduI))*0.1, dev_time_aduI,
main = paste("Development days JuvenileI vs fit \n min_size =", adultI_min, "mm and max_size = ", adultI_max ,"mm") )
lines(temperature_range_red_aduI, predict(fit_aduI), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### ADULT II####
development.df_aduII <- data.frame(row = seq(1, 1095))
#simulate development with constant temperature for each 0.1°C & store results columns wise in the df:
for (i in temperature_range){
development <- c()
initial_l <- adultII_min #cm
for (j in time_range){
growth = som_growth_thesis(initial_l, j ,i , parameters_solv$Fem_params)
#initial_l = growth #+  L_init
development = append(development, growth)
}
development.df_aduII[as.character(i)] <- development
}
development.df_aduII = development.df_aduII[ , !(names(development.df_aduII) == "row")] #delete first column with timesteps, same as index
#Count how many time steps there are, where individual's size is between min and max size of its size class range:
dev_time_aduII <- sapply(development.df_aduII, function(col){
BrownShrimp::count_devDays(col, adultII_min, adultII_max) } )
#With following plot, we know the shape of the curve (U shape. But inverted is again TPC)
plot( (1:length(dev_time_aduII))*0.1, dev_time_aduII, main = "Development days Adult II \n min_size = 6 cm and max_size = 7 cm" )
plot( (1:length(dev_time_aduII))*0.1, 1/dev_time_aduII, main = "1/Development days Adult II \n min_size = 6 cm and max_size = 7 cm" )
lines(temperature_range, k_vals_F, col = 'red', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red"))
#Deleet values where there is no development i.e. when devTime = 1095
indexes_1095 <- which(dev_time_aduII == 1095 | dev_time_aduII == 0)
dev_time_aduII_reduced <- dev_time_aduII[dev_time_aduII != 1095]
temperature_range_red_aduII <- temperature_range[-indexes_1095]
k_vals_reduced_aduII = k_vals_F[-indexes_1095]
devTime_aduII_inv_reduced = 1/dev_time_aduII_reduced
k_vals_reduced_aduII_inv = 1/k_vals_reduced_aduII
fit_aduII = lm(dev_time_aduII_reduced ~ k_vals_reduced_aduII_inv )
summary(fit_aduII)
plot( (1:length(dev_time_aduII))*0.1, dev_time_aduII,
main = paste("Development days JuvenileI vs fit \n min_size =", adultII_min, "mm and max_size = ", adultII_max ,"mm") )
lines(temperature_range_red_aduII, predict(fit_aduII), col = 'red4', lwd = 2)
legend("topright", legend = c('1/devTime', 'K_func_briere'), fill = c("black", "red4"))
#### DEV. TIME FITS SUMMARY  ###
#Here we just summerize the results of the linear fits development time funciton:
interceptsF_devTime = c(coef(fit_JuvI)[1], coef(fit_juvII)[1], coef(fit_juvIII)[1], coef(fit_juvIV)[1], coef(fit_juvV)[1], coef(fit_aduI)[1], coef(fit_aduII)[1])
factorsF_devTime = c(coef(fit_JuvI)[2], coef(fit_juvII)[2], coef(fit_juvIII)[2], coef(fit_juvIV)[2], coef(fit_juvV)[2], coef(fit_aduI)[2], coef(fit_aduII)[2])
sizeClass_means_reduced = sizeClass_means[1:length(sizeClass_means)-1]
fits_F_df = data.frame( row.names = sizeClass_names[1:length(sizeClass_names)-1], intercept = interceptsF_devTime, factor = factorsF_devTime)
mean_intercept_F = mean(fits_F_df$intercept)
fit_intercepts_F = lm(fits_F_df$intercept ~ sizeClass_means_reduced)
summary(fit_intercepts_F)
plot(1:(length(sizeClass_names)-1), fits_F_df$intercept, xlab = 'size class', ylab = 'intercept for dev. time')
abline(h= mean(fits_F_df$intercept), lty=2 )
lines(1:(length(sizeClass_names)-1), predict(fit_intercepts_F), col = 'orange3')
#As result we see a roughly linear increasing relation, however the average could
#also represent well the intercept value
#check weather FACTORS show any relation with the mean size of the class:
plot(1:length(sizeClass_means_reduced), fits_F_df$factor, col = 'red', ylim = c(-0.05, 0.8),
xlab = 'size class', ylab = 'facor for dev. time')
lines( 1:length(sizeClass_means_reduced), sizeClass_means_reduced/10)
#As result we see either a linear growing relation, an exponential or a power-law relation
##Test fit to Power-law relation:
#fit_factorts = nls(fits_df$factor ~ a * exp(b * sizeClass_means_reduced), start = list(a = 0.05, b = 0.2))
logx = log(sizeClass_means_reduced)
logy = log(fits_F_df$factor)
fit_factortsLog_F = lm(logy ~ logx)
summary(fit_factortsLog_F)
log_a_F <- coef(fit_factortsLog_F)[1]
b_est_F <- coef(fit_factortsLog_F)[2]
a_est_F <- exp(log_a_F)
plot(sizeClass_means_reduced, fits_F_df$factor, log = 'xy')
lines(sizeClass_means_reduced, a_est_F * sizeClass_means_reduced^b_est_F, col = 'red')
plot(sizeClass_means_reduced, fits_F_df$factor, ylim = c(0.1, 0.8))
lines(sizeClass_means_reduced, a_est_F * sizeClass_means_reduced^b_est_F, col = 'red')
fit_factortsExp_F = nls(fits_F_df$factor ~ a * 2^(sizeClass_means_reduced*b),
start = list(a = 0.1, b = 0.5))
summary(fit_factortsExp_F)
plot(sizeClass_means_reduced, fits_F_df$factor, main = 'Fit exp 2^L function against factors', ylim = c(0,0.9))
lines(sizeClass_means_reduced, predict(fit_factortsExp_F), col = 'red')
growth_optionA_t = function(L_mean, temperature, sex_params){
intercept = mean_intercept_F #-0.4968367 #mean_intercept
factor = a_est_F * L_mean^b_est_F #
k = K_func_briere(temperature, sex_params)
return(1/ (intercept + factor*(1/k)) )
}
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))
ind = 1
for (i in sizeClass_names){
plot(temperature_range,  1 / (fits_F_df[i, 'intercept'] + fits_F_df[i, 'factor']*(1/k_vals_F) ),
main = paste('growth', i ,'vs function'), ylim = c(0, 0.1), ylab = "growth rate",
las = 1, cex.main = 1.4, cex.lab = 1.3, cex.axis = 1.5 )
lines(temperature_range, sapply(temperature_range, growth_optionA_t, L_mean = sizeClass_means[ind],
sex_params=parameters_solv$Fem_params ) , col = 'red3' , lwd = 1.8)
ind = ind + 1
}
plot.new()  # empty plot
legend("center", legend = c('1/devTime', 'growth function'), fill = c("black", "red3"))
growth_optionB_t = function(L_mean, temperature, sex){
intercept = -0.538245 + L_mean* 0.003394 #mean_intercept
factor = a_est_F * L_mean^b_est_F #
k = K_func_briere(temperature, sex)
return(1/ (intercept + factor*(1/k)) )
}
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))
ind = 1
for (i in sizeClass_names){
plot(temperature_range,  1 / (fits_F_df[i, 'intercept'] + fits_F_df[i, 'factor']*(1/k_vals_F) ),
main = paste('growth', i ,'vs function'), ylim = c(0, 0.1), ylab = "growth rate", las = 1, cex.main = 1.4, cex.lab = 1.3, cex.axis = 1.5 )
lines(temperature_range, sapply(temperature_range, growth_optionB_t, L_mean = sizeClass_means[ind], sex=parameters_solv$Fem_params ) , col = 'red3' , lwd = 1.8)
ind = ind + 1
}
plot.new()  # empty plot
legend("center", legend = c('1/devTime', 'growth function'), fill = c("black", "red3"))
#CONCLUSION COMPARATION A and B:
#No relevant difference, therefore for the sake of simplicity and saving computing effort
#option A was chosen.
#NOW CHECK FACTOR AS EXPONENTIAL FUNCTION
#here we use both factor and intercept as funciton of L mean:
growth_optionC_t = function(L_mean, temperature, sex){
intercept = -0.538245 + L_mean* 0.003394
factor = coef(fit_factortsExp_F)[1] * 2^(L_mean*coef(fit_factortsExp_F)[2] )
k = K_func_briere(temperature, sex)
return(1/ (intercept + factor*(1/k)) )
}
par(mfrow = c(3, 3), mar = c(4, 4, 2, 1))
ind = 1
for (i in sizeClass_names){
plot(temperature_range,  1 / (fits_F_df[i, 'intercept'] + fits_F_df[i, 'factor']*(1/k_vals_F) ),
main = paste('growth', i ,'vs factor with exp. function '), ylim = c(0, 0.1), ylab = "growth rate", las = 1, cex.main = 1.4, cex.lab = 1.3, cex.axis = 1.5 )
lines(temperature_range, sapply(temperature_range, growth_optionC_t, L_mean = sizeClass_means[ind], sex=parameters_solv$Fem_params ) , col = 'red3' , lwd = 1.8)
ind = ind + 1
}
plot.new()  # empty plot
legend("center", legend = c('1/devTime', 'growth function'), fill = c("black", "red3"))
#CONCLUSION: in comparision with Power-Law funciton, the deviation on first size class larger and
#additionally there is signifficant difference in second size class.
molting_fraction_Temming <- function(L, temperature){
mf = 0
if (L >= 5.5){
L=10*L
mf = (1 / (5.7066 * L^0.7364 * exp(temperature*-0.09363) ) ) #revision 28.05. Temming's implementation (above was Temming's formula on paper)
}
return ( mf )
}
vB_term = function(L, fem_params, Te){
w = convertL_to_W(L)
return(3*K_func_briere(Te, parameters_solv$Fem_params)*w)
}
number_eggs <- function(L){
L=L*10
0.01805*L^3.539 #incongruency on Temming's paper weather 0.01805 or 0.001805. The first seem more plausible for me
}
temp_range_wide = seq(1,40, 0.1)
par(mfrow=c(1,1))
plot(temp_range_wide, molting_fraction_Temming(6, temp_range_wide), ylim = c(0,0.4), main = "Molting fraction Temming vs Bertalanffy term \n L=6cm",
xlab = 'T [°C]', ylab = 'molting fraction')
abline(h = 1, lty= 2) #Surpassing one is very unrealistic !
lines(temp_range_wide, sapply(temp_range_wide, vB_term, L=6, fem_params=parameters_solv$Fem_params), col = 'red')
avg_weight_egg = 17.725*10^-6 #[gr] ~avg 17.725 microgramm over the year (from table from seasonal changes on eggs Urzua)
temp_range = seq(0,30, 0.1)
mat_size_range = seq(5.5, 8.5, by = 0.1)
fem_abundance <- 1 #number of females (we will consider first also a constant size L=6 cm)
L_test1 <- 6 #cm
#TEMING
# SI = C_l * E_l * EF_l * MF_l
# c_l: number of individuals per a size class 'l'
# E_l: Share of egg-bearing Fem in size class 'l'
# EF_l: mean number of eggs per size class
# MF_l: molting frequency
number_eggs <- function(L){
0.01805*L^3.539 #incongruency on Temming's paper weather 0.01805 or 0.001805. The first seem more plausible for me
}
#### SIMULATIONS ####
temp_range = seq(1,30, 0.1)
eggs_production_temming <- c()
eggs_production_AF <- c()
spawning_rate_vB <- function(L, temperature){
s = 0
if(L>5.5) s = convertL_to_W(L)*K_func(temperature)*3
return(s)
}
spawning_s = data.frame(row = seq(1, length(temp_range)))
egg_prod_T = data.frame(row = seq(1, length(temp_range)))
for (s in mat_size_range){
eggs_production_temming = c()
eggs_production_AF = c()
for (i in temp_range){
prod_temming <- fem_abundance*number_eggs(s*10) #L*10 because Temming's fomula is in mm
#B_fe = convertL_to_W(s)
#prod_AF <- B_fe*fem_abundance*spawning_rate_vB(s, i)#, parameters_solv$Fem_params) #Biommass
prod_AF <-fem_abundance*spawning_rate_vB(s, i)#, parameters_solv$Fem_params) #Biommass
eggs_production_temming <- append(eggs_production_temming, prod_temming) #number of eggs
eggs_production_AF <- append(eggs_production_AF, prod_AF) #biomass
}
spawning_s[as.character(s)] <- eggs_production_AF
egg_prod_T[as.character(s)] <- eggs_production_temming
}
Teming_biomass = egg_prod_T[, 2:ncol(egg_prod_T)]*avg_weight_egg#eggs_production_temming*avg_weight_egg #[gr]
plot(temp_range, Teming_biomass$'6', ylim = c(0,0.7))
lines(temp_range, spawning_s$'6', col = 'red')
factor = c()
for (i in 1:ncol(Teming_biomass)){
B_i = convertL_to_W(mat_size_range[i])
factor = append(factor, Teming_biomass[[i]][1]/B_i)
}
B_sc =  convertL_to_W(mat_size_range)
logx = log(B_sc)
logy = log(factor)
fit_factortsLog = lm(logy ~ logx)
summary(fit_factortsLog)
log_a <- coef(fit_factortsLog)[1]
b_est <- coef(fit_factortsLog)[2]
a_est <- exp(log_a)
plot(B_sc, factor, log = 'xy')
lines(B_sc, a_est * B_sc^b_est, col = 'red')
plot(B_sc, factor, ylim = c(0.2, 0.4))
lines(B_sc, a_est * B_sc^b_est, col = 'red')
plot(B_sc, factor)#, ylim = c(0.2, 0.4))
lines(B_sc, a_est * B_sc^b_est, col = 'red')
library(deSolve)
library(RColorBrewer)
library(BrownShrimp)
library(viridis)
library(dplyr)
library(tidyr)
library("colorspace")
#library(lubridate)
library(latex2exp)
library(profvis)
library(stringr)
#library(devtools)
#Read water temperature from Germany:
temperature_germany <- read.csv("./data/temperature_10ger.csv")
#Filter years from 2010 to 2015
tempG.10_15 = temperature_germany %>% filter(date_time > as.Date("31/12/2009", format = "%d/%m/%Y") & date_time < as.Date("01/01/2016", format = "%d/%m/%Y"))
#Read landings data
ble_data = read.csv("./data/BLE_Inlandslandungen_SpeiseKrabbe.csv", sep = ';')
t_years = seq(0,length(tempG.10_15$temperature)-.1)
#initialize Initial conditions: This IC were determined in file '/scriptsThesis / setInitialConditions.R'
BF_p = c(3.801852,  7.063263,  12.657331, 25.166351, 49.297133, 45.876772, 34.672340,  19.396426)
BM_p = c(4.573332  , 8.203546 , 13.791605 , 26.328928 , 43.371121  )
IC_parameterized.v2 = c(P = 2, E = 2, L= 1 ,
BF = BF_p, BM = BM_p)
##### Initialitze parameters for comparation of 4 diff scenarios: no pressure, fishery, pred and both ####
#No pressure
noPreasure_params = parameters_solv
devtools::load_all(".")
noPreasure_params = parameters_solv
noPreasure_params$general_params$Fi = 0 #No fishery
noPreasure_params$general_params$Imax_ik = 0 #No predation
#Only predation
pred_params = parameters_solv
pred_params$general_params$Fi = 0 #No fishery
pred_params$general_params$Imax_ik = 0.185
#Only Fishery
fishery_params = parameters_solv
fishery_params$general_params$Imax_ik = 0 #No predation
fishery_params$general_params$Fi = 4/365
##### (A) SIMS YEARS BEFORE 2016: 20mm cod-end #####
# THESIS VALIDATION: abundance (vs Fishery) .V5 #
bothPF_params = parameters_solv
bothPF_params$general_params$Fi = 4/365 #(1-exp(-5))/365
bothPF_params$general_params$L50 = 3.69 #et. al Santos 2018
bothPF_params$general_params$SR = 0.75 #et. al Santos 2018
bothPF_params$general_params$Imax_ik = 0.16 #(1-exp(-2))/365 #reduce predation in these years as per: https://www.openseas.org.uk/news/on-thin-ices-north-sea-cod/
BF = c(8.695212, 15.349638, 21.461595, 24.672213,25.871618, 17.536662, 14.090960, 11.933151)
BM = c(10.85817, 19.93554, 29.01086, 36.67041, 58.26882)
Init.v3 = c(P = 2, E = 2, L= 1 ,
BF = BF, BM = BM)
start <- Sys.time()
FP_10_15_g <- solver_sizeClass.v5(t = t_years, state = Init.v3, parameters = bothPF_params, temperature_dataSet = tempG.10_15)
print(Sys.time() - start)
plot_sizeSpectra_old(sol_df_main = FP_10_15_g, year = 2014, title = "F&P")
?solver_sizeClass.v5
?solver_sizeClass.v5()
?respiration_rate_b
